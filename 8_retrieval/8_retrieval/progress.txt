First need to fix oncoming headache
 Fill up water bottle
  
Pomo 1: 5:43 --> 6:08
Goal: Look through and summarize pset 

9 Parts 
 1: make_constellation
  spectrogram --> point constellation
  remember that constellation is Px2 matrix of local peaks in spectrogram
 2a: expected points in song
  Currently unsure why there would be an expectation of number of points 
 2b: Compare eq vs # pts actually generated
  What happens and why
 3: Determine matching function DeltaC(m) from database C(D) and query C(Q)
  Probably a sliding numpy * operation, since it is probably just 0's and 1's 
 4a: Determine hash lists L(h) for database C(D) using hash fxn h = k
 4b: use those hash lists to compute DeltaC(m) using indicator fxn method
  Consult the retrieval doc for refresher on this
 5: points_to_hash
  Px2 matrix of constellation points into hash lists w/ hash fxn h=k
  Output is python dictionary {h vals: [timestamp of n]}
 6: hash_match
  Finds best timestamp that aligns the query points with the databasepoints 
  db_hash (a dictionary of hash liss for the database)
  query (list of query points where each point is (n,h)) -- h is still =l
   The hash value of the point is the same as the frequency stamp
  Output -- best timestamp, score (num point intersections when query shifted by timestamp) 
  Test with beatles song
 7: Points to triplet hash (more interesting hashing scheme)
  Each item calculated from a pair of points: anchor and fanout
 8: Explore audio matching
  Create database of one song
  dtw_match_cost calcs warping paths that best match query to database w/ dynamic time warping
 9: get match regions
  return list of matching paths from results of dynamic time warping

This lab is Shazam
But want to do as much processing remotely as possible
So have phone do the compression scheme
 Making that the query
Store all song data in such a way that it can be matched to those hashed queries 

Go pee, then run through the retrieval doc

Pomo 2: 6:10 --> 6:35
Goal: Summarize the retrieval doc, do exercise 1

Different levels of audio retrieval problem

Paper by Avery Wang -- 2003
 Audio Identification  aka audio fingerprinting

System overview
 
User
 audio frag  ----------------------------fingerprint--> audio fingerprints
 ^ (metadata to user)             send fingerprints to service |(down) 
 metadata db <-use id fingerprints to look up metadata- fingerprint db
Server

Properties 
 High specificity - discriminative
 highly robust -- invariant to distortions
 compact
 scalable

Figure out what time this place closes to know if getting dinner here
9:00 <-- hold out for soylent after closing, already spending too much money
 Got tea, should be soothing in the mean time

Only 12 minutes left

Spectrogram with fairly small hop_size

Why is num points not just division of areas in peak picking

This peak picking is pretty robust 

Concatenate may songs --> Database
database D and constellation map C(D)

Query is small frament of audio recording
 1.5 second time slice of audio could be used as query

Pick best shift as most matches
Best shift is pretty robust as well

4 minutes

Query is against many songs
 Since DB is a concat
 Keep track of time-offset per song in DB

Query optimization
 Compute hash value h for eah constellation point (n,k)
 h is a fixed length binary number (usually)

Pomo 3: 6:35 --> 7:00
Goal: Finish summarizing the retrieval doc, do exercise 1

Need to understand the hashing scheme

Hash value h for each constellation point (n,k)
In example, hash takes on y values (1,2,3,4)
I think the hashing scheme is just modulo
 We'll find out, start the pset

Ex 1: make constellation
May want to do lab first -- this may take a while
 No matter what, need to get this pset done tonight 
 Pomo through lab 8. use the textbook if necessary -- on song id
 Opened textbook -- there are ~50 pages on audio id
  Hopefully will not need to consult

If I go through the lab, I will understand the hash function and save some work
Change goal -- lab 8
Switched music to intervals radio
 
Pomo 4: 7:00 --> 7:25
Goal: Exercises 1-4 of the lab

Exercise 1
 Find song -- add to folder -- polytonal linkin park -- done

Exercise 2
 hash_of_name function through dictionary of names 
 the hash is sum(map(ord,name))%10
 
Exercise 3
 make dictionary hash_list
 keys are hash values
 values of each key is accumulated list of the favorite numbers of the hash of the name

 Draw picture of input/outputs
  name_to_fav_nums --> hash_to_accumulated_fav_nums
  need loop to go through the names to see which give same hash
  
 Need python functional tools
  potentially use groupby
 Example of use of groupby, compress
 
 compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F
 not quite sure how groupby works

 groupby is the key

Pomo 5: 7:28 --> 7:53
Goal: Exercises 3-5

Groupby successful in grouping the names by hash
Done w/ ex 3, sent to Eran

4b -- find points of local maxima
 Apply maximum_filter to X -- named grey_scale

Redo 4C for understanding -- about to find peaks using img_max (filtered gray scale img)
 point is local max if X(x,y) == Xmax(x,y)
 Now format as Px2 matrix
  Two arrays, though I do not know corresponding order -- y,x

Pomo 6: 7:58 --> 8:23
Goal: Exercise 4 - 6

How to put red dots onto array
plt.plot(x array, y array, 'ro')

Same as ground truth from lab -- good

Ex 5 -- find top n peaks
 x -- signal, n = num peaks, win_hlen
 
 strategy
  find the max val
  modify the signal to squash region around peak
  repeat

 how to get numpy max index
  np.argmax
 success

Ex 6 --fingerprint database w/ all songs
 Try query -- success
 Done

Pset
 Ex 1 -- just copy method from lab

I have noticed that I am getting more distracted
 Consider taking a break
 They close in 45 minutes

How to take break without the corresponding drain in motivation/feeling bad?
 That is an important part of it
 Good to take break that doesn't make me feel guilty
Taking brisk walk is a good way
Social break is good
they say 90 minute work cycles is good -- 4 to 5 pomo's -- interesting

Break should only be 10 - 15 minutes (experiment on this) to feel ready to work afterwards
 Kind of like nap

Doing something hands on 
Learn something new -- like brilliant maybe
Do a good deed

meditate -- would be good to get into this
 
Right now, the best play is to take a walk 

Want to continue working on campus, but for that need to have dinner
 Should have brought soilent
 But instead pick up a sandwitch from roxy's, and work in the library

Pomo 7: 9:00 --> 9:25
Goal: Exercise 1 and 2

need to make_constellations
 remember steps from lab
 First do max filter, then check where equal
How to load audio into snd file
 load_wav. How to set fs?
 Assume 22050 samples/sec
  Played audio -- sounds right, also 2:51 length sounds correct
 Only load first 10 seconds
 Can use t_end and t_start (assuming in seconds)
  Worked
 Imshow giving error
 Try just plotting
  Error bc imshow can't do complex vals
  take abs -- works
 Need to restrict to 0 - 4000 Hz
  What k bins does that correspond to?

 Convert Hz to k bin
  That conversion should be dependent on N
 k bin corresponds to frequency that has k periods/N samples
 
 fs = samples / sec
 so (k/N)*fs is periods/sec, so (k/N)*fs*2*pi is rads/sec
 f = (k*fs*2*pi)/N

 How to slice out y section -- [a:b,:]
 success

 use lab to get 2D peaks
 Still getting imshow cannot accept Complex

Pomo 8: 9:25 --> 9:30
Goal: Ex 1 and 2

time_len and freq_len are in secs and Hz
Not sure if can do freq to k in len -- I shouldn't be able to ...
Use the fmp.find_area_peaks

What are the input units of find_area_peaks?
 Is peak finding, but I'm not sure that it has the right size
 Probably not -- 0.5 sec means should be only 20 left to right

need to go from time to num samples
 just use sample rate and hop_size
 hop_size is samples
 want units of samples, from time
 t seconds * fs samples/sec / hop_size 

Need to convert from Hz to k as well
Did

Messaged Zumbo to check answer

Get started on 2a

Assume that sg has uniform distribution of bumps contours
Write eq for expected number of constelation points

Pomo 9: 9:50 --> 10:15
Goal: Exercise 2 and 3

Set up the peaks and num_pts
make interact
actually better to do plot

How to do map for multiple arguments
 Just regular with other arg
But I actually don't want to do multi-dim map
 Would be nice to pass over matrix
How to create matrix from function?

>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]], dtype=bool)

Written 
 Error, array being passed to f_to_k

 Maybe index into np.linspace is an array -- no
 coming into function as array

Could separate step in matrix build, then apply
Or figure out here
Try mgrid or fromiter

Pomo 10: 10:22 --> 10:47
Goal: Exercise 2 and 3

Finished 2,3

Use indicator function method
 For each point (n,h) in the query, compute shift amt m = l-n for each l in L(h)

What does this represent?
Do I fold the -1 to 7? -- no, fold to 8!

Wow this is the same answer as delta C by eye-balling!
Unsure how this working though

Observation -- jerking is not great for the same reason futurama is not great
 too long --> guilty --> want to procrast more

Pomo 10: 12:13 --> 12:38
Goal: Exercise 5 and outline 6

Exercise 5
 points_to_hash
 Outputing dictionary

Need to aggregate based on values of y
Done

Pomo 11: 12:38 --> 1:03
Goal: Exercise 6 and 7

Ex 6 
 Figure out best timestamp
 Inputs 
  db_hash
  query
 Outputs
  best timestamp
  best score

Strategy
 Use algo from 4b
 h --> m = l - n
 ^Should be simple map
Getting a bit confused on the ordering

Should do preemptive coffee
 Done

Now what is relationship between L(h) and my table
 Same thing

Query is a list of points (n,h)

How to find x size of the full signal
 used db_audio.size[1]

Pomo 12: 1:04 --> 1:29
Goal: Ex 6 and 7

Count to count num times element appears
Return largest value in dictionary 

Should look in textbook to see if wrap around
 Not wrap around. negative!
Then how high should I check m

Do I hash the query?
 No, I don't
Why so slow?
 Not slow, some error somewhere -- fixed

Pomo 13: 2:18 --> 2:43
Goal: Ex 7

points to triplet hash

inputs
 points: Px2 matrix of points
 return_list: Boolean. If True return list, else dictionary
output:
 if dictionary: {h: [timestamp n]}
 else: [(n,h)]

Strategy
 Iterate through all input points
 For each pt (n0,k0), find all pts in the fanout zone
  
What to do if list

What are values of the dictionary?
 Should be list of shift values
 
 So group by that relationship in n and k

 First create dictionary of pts to fanout zone points

 for some reason double for loop comprehension with if not working
 test in shell
 Syntax generally ok

Plan -- do Chem before 12, and finish here

_______________

Pomo 14: 6:36 --> 7:01 
Goal: Part 7, outline 8

How to deal with indexing based on query n,h
 Should I be filtering the query 
 map query to hash -- but how to pick anchor
What should return list look like

Still key error in db_hash[h]
Then reduce not reducing anything
 Possible m's empty?

___________________ Saturday

Pomo 1: 10:35 --> 11:00
Goal: Flesh out hashing situation

Really make sure that I understand the under lying concepts
Get out notebook and go through textbook section

Read throught the the hashing section for the first hash type
 Very nice presentation
 The DetlaC is the indicator function of the hashed query slid along the hashed database
 Database considered as one item because can always concatenate and good for notation
 Big speed up from using the pairwise hash (10000x) w/ 10x more memory
 Nice analogy to book indexing where the hash = word, timestamp = page number

Pomo 2: 11:00 --> 11:25
Goal: Finish conceptual understanding

Could stand to work through the alternate hash in the book
Also where to work tonight? -- what spots on bu are open
 Working at the house will not work
Do I actually think that I will get work done
 Probably not
 Might as well go then
  But I will be distracted, and unable to focus
This really is a lose-lose situation
Should hole up in a library
 My issue is that formal will take such a long time, I will there was something in the middle
Want to go to sleep early to get ready for the next day, because I will not be ready early
 Have very productive day today and can look forward to this
  This will make me more productive during the day
Got formal stuff all sorted out

Pomo 3: 12:00 --> 12:25
Goal: Understand pairwise hashing scheme

Increases bceause loop only over the hash values in the query
L(h) is a list of amounts that a query point needs to be shifted to hit database hash
Complexity is MN/L, as opposed to MN

Pomo 4: 12:25 --> 12:50
Goal: Finish Ex 7

Should triplet query be a list?
What form should query be in?
 Note -- I am actually less effecient when beyond deadline for something

Form of the query
 List of points
 Why?

Issue is that I am hashing inside of the hash_match!

Feature representation is a list of points (constellation)
hash is a bunch of {h:[timestamp]} values afterwards
bring hashed query into (n,h) list form

Could I convert directly from (n,k) constellation points to (n,h)

Pomo 5: 12:50 --> 1:15
Goal: Ex 7

hash_match(database - {h:[timestamps n], query - [(n,h)]}
Did exercise 7!
 There was some sort of issue in the dict.iteritems()!

Pomo 6: 1:15 --> 1:40
Goal: Ex 8

Explore audio matching
Create audio database of one song
 Generally many songs

dtw_match_cost -- calc warping paths that best match a query to a database

Inputs:
 C -- NxM cost matrix comparing query (len N) to a database (len M)
Outputs:
 D -- accumulated cost matrix 
 B -- backtroacking matrix

How to create matching function
 DeltaDTW(m) = D(N,m)

Pomo 7: 2:35 --> 3:00
Goal: Figure out matching fxn, ex 8

Done
Now get match regions

Pomo 8: 3:00 --> 3:25
Goal: finish ex 9

How to use dictionary item in map
 itemgetter?
 just use comprehension

getting out of bounds when accessing B
 was using wrong index dim -- causing bad troughs
Now play audio 

how to adjust play back rate
